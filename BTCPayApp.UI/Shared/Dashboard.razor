@inject IState<RootState> State
@inject IDispatcher Dispatcher
@inject IState<OnChainTransactionsState> OnChainTransactionsState
@using Microsoft.AspNetCore.SignalR.Client
@using BTCPayApp.UI.Features
@using BTCPayApp.UI.Pages
@using BTCPayApp.Core
@inherits Fluxor.Blazor.Web.Components.FluxorComponent

<MudText Typo="Typo.h5" Class="mb-4">Dashboard</MudText>

@if (State.Value.Loading.Contains(RootState.LoadingHandles.PairConfig))
{
    <MudAlert Severity="Severity.Info">Pairing configuration loading.</MudAlert>
}
else if (State.Value.PairConfig is not null)
{
    <MudAlert Severity="@ConnectionSeverity">
        <div class="d-flex align-center justify-space-between gap-3">
            Your BTCPay Server is paired. Connection status is @ConnectionStatus.
            @if (State.Value.BTCPayServerConnectionState == HubConnectionState.Disconnected)
            {
                <MudButton Href="@Routes.Pair" Variant="Variant.Text" Color="Color.Error" Size="Size.Small">
                    Configure connection
                </MudButton>
            }
        </div>
    </MudAlert>
}
else
{
    <MudAlert Severity="Severity.Warning">
        <div class="d-flex flex-wrap align-center justify-space-between gap-3">
            No BTCPay Server paired.
            <MudButton Href="@Routes.Pair" Variant="Variant.Filled" Color="Color.Primary" Size="Size.Small">
                Configure connection
            </MudButton>
        </div>
    </MudAlert>
}

@if (State.Value.Loading.Contains(RootState.LoadingHandles.WalletConfig))
{
    <MudAlert Severity="Severity.Info">Wallet configuration loading.</MudAlert>
}
else if (State.Value.WalletConfig is not null)
{
    <MudAlert Severity="Severity.Success">Your wallet is configured.</MudAlert>
}
else
{
    <MudAlert Severity="Severity.Warning">
        <div class="d-flex flex-wrap align-center justify-space-between gap-3">
            Your wallet is not configured.
            <MudButton Href="@Routes.WalletSetup" Variant="Variant.Filled" Color="Color.Primary" Size="Size.Small">
                Set up a wallet
            </MudButton>
        </div>
    </MudAlert>
}

@if (State.Value.Loading.Contains(RootState.LoadingHandles.LightningState))
{
    <MudAlert Severity="Severity.Info">Lightning node loading.</MudAlert>
}
else
{
    <MudAlert Severity="@LightningSeverity">Your Lightning node is @LightningStatus</MudAlert>
}

@if (State.Value.Loading.Contains(RootState.LoadingHandles.TransactionState))
{
    <MudAlert Severity="Severity.Info">Transactions loading.</MudAlert>
}
else
{
    <MudText Typo="Typo.h6" Class="mt-8" GutterBottom="true">Transactions</MudText>
    @if (OnChainTransactionsState.Value.Error is not false)
    {
        <MudAlert Severity="Severity.Warning">
            <div class="d-flex flex-wrap align-center justify-space-between gap-3">
                There was an error loading your transactions.
                <MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Small" OnClick="() => Dispatcher.Dispatch(new OnChainTransactionsState.LoadTransactionsAction())">
                    Retry
                </MudButton>
            </div>
        </MudAlert>
    }
    else if (OnChainTransactionsState.Value.AllTransactions?.Any() is true)
    {
        <MudList>
            @foreach (var tx in OnChainTransactionsState.Value.AllTransactions)
            {
                <MudListItem>
                    <MudListItemText>
                        <div class="d-flex align-center justify-space-between gap-3">
                            <div>
                                <MudText Typo="Typo.body2" Class="mb-1">@tx.Value.Id</MudText>
                                <MudText Typo="Typo.caption" Class="mb-1">@tx.Value.Timestamp</MudText>
                            </div>
                            <div>
                                <MudText Typo="Typo.body2" Class="mb-1">@tx.Value.Balance</MudText>
                                <MudText Typo="Typo.caption" Class="mb-1">@tx.Value.Status</MudText>
                            </div>
                        </div>
                    </MudListItemText>
                </MudListItem>
            }
        </MudList>
        <MudButton Variant="Variant.Filled" Color="Color.Default" Size="Size.Small" OnClick="() => Dispatcher.Dispatch(new OnChainTransactionsState.LoadTransactionsAction())">
            Refresh
        </MudButton>
    }
    else
    {
        <MudText GutterBottom="true" Color="Color.Tertiary">There are no transactions, yet.</MudText>
    }
}
@code {
    private string ConnectionStatus => State.Value.BTCPayServerConnectionState?.ToString().ToLowerInvariant() ?? "not connected";

    private Severity ConnectionSeverity => State.Value.BTCPayServerConnectionState switch {
        HubConnectionState.Disconnected => Severity.Warning,
        HubConnectionState.Connected => Severity.Success,
        HubConnectionState.Connecting => Severity.Info,
        HubConnectionState.Reconnecting => Severity.Info,
        _ => Severity.Warning
        };

    private string LightningStatus => State.Value.LightningNodeState switch {

        LightningNodeState.NotConfigured => "not configured",
        LightningNodeState.WaitingForBackend => "waiting for the backend",
        LightningNodeState.ShuttingDown => "shutting down",
        LightningNodeState.Error => "in error state",
        _ => State.Value.LightningNodeState.ToString().ToLowerInvariant()
    };

    private Severity LightningSeverity => State.Value.LightningNodeState switch {
        LightningNodeState.Bootstrapping => Severity.Info,
        LightningNodeState.Starting => Severity.Info,
        LightningNodeState.WaitingForBackend => Severity.Info,
        LightningNodeState.Connected => Severity.Success,
        LightningNodeState.Error => Severity.Error,
        _ => Severity.Warning
        };

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return base.OnAfterRenderAsync(firstRender);
        if (State.Value.BTCPayServerConnectionState is not HubConnectionState.Connected)
            Dispatcher.Dispatch(new OnChainTransactionsState.LoadTransactionsAction(true));
        return base.OnAfterRenderAsync(firstRender);
    }

}
