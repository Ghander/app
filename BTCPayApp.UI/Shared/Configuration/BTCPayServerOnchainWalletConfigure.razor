@using System.ComponentModel.DataAnnotations
@using NBitcoin
@* if there is a configured wallet, and it is hot, ask if the user would like to import and use that within the app *@
@* if there is a configured wallet, and it is not hot, ask if the user would like to provide the seed to the app *@
@* if there is no configured wallet, ask if the user would like to create a new wallet *@
@* if the user would like to create a new wallet, ask if the user would like to import it into BTCPayServer store as a hot or cold wallet *@

@if (ConfiguredWallet is not null)
{
    <MudAlert Severity="Severity.Warning" Class="mb-4">
        @if (IsConfiguredWalletHot)
        {
            <MudText>Your BTCPay Server store already has an onchain hot wallet configured.</MudText>
        }
        else
        {
            <MudText>Your BTCPay Server store already has an onchain watch-only wallet configured.</MudText>
        }
    </MudAlert>
}

<ValidationEditContext Model="this" @ref="_validationEditContext" Validate="Validate" OnValidSubmit="OnSubmit">
    <MudRadioGroup Label="Wallet Creation Options" Class="mb-4" @bind-SelectedOption="@SelectedOption" For="() => SelectedOption">
        @foreach (var option in Options)
        {
            <div>
                <MudRadio T="string" Option="@option.Key" Class="align-start">
                    <div class="d-flex flex-wrap gap-3 pt-3">
                        <MudText>@option.Value.Item1</MudText>
                        @if (option.Value.Item2)
                        {
                            <MudChip Variant="Variant.Text" Color="Color.Warning" Size="Size.Small" Class="ma-0">Your existing wallet will be overwritten!</MudChip>
                        }
                    </div>
                </MudRadio>
            </div>
        }
    </MudRadioGroup>
    @if (IsMnemonicRequired)
    {
        <MudTextField
            @bind-Value="Mnemonic"
            HelperText="Mnemonic Seed"
            Variant="Variant.Outlined"
            AdornmentIcon="@Icons.Material.Filled.Refresh"
            Adornment="Adornment.End"
            OnAdornmentClick="GenerateSeed"
            For="() => Mnemonic"/>
    }
    <MudButton ButtonType="ButtonType.Submit" Variant="Variant.Filled" Color="Color.Primary" Disabled="_validationEditContext.Invalid" Class="mt-3">
        Continue
    </MudButton>
</ValidationEditContext>

@code {
    [Parameter]
    public string? ConfiguredWallet { get; set; }

    [Parameter]
    public bool IsConfiguredWalletHot { get; set; }

    private bool IsMnemonicRequired
    {
        get { return new[] {"use-configured-wallet",  "create-wallet", "create-wallet-separate"}.Contains(SelectedOption); }
    }

    private Dictionary<string, (string, bool)> Options
    {
        get
        {
            var result = new Dictionary<string, (string, bool)>();
            var hasWarning = false;
            if (ConfiguredWallet is not null)
            {
                if (IsConfiguredWalletHot)
                {
                    result.Add("use-configured-hot-wallet", ("Import the configured hot wallet", false));
                }

                result.Add("use-configured-wallet", ("Import the configured wallet but store the keys on app", false));
                hasWarning = true;
            }

            result.Add("create-wallet", ("Create a new wallet to use on BTCPay Server and store the keys on app", hasWarning));
            result.Add("create-wallet-separate", ("Create a new wallet to be used only on app", false));
            return result;
        }
    }

    [Required]
    private string? SelectedOption { get; set; }

    private string Mnemonic
    {
        get => _mnemonic;
        set
        {
            _mnemonic = value;
            _validationEditContext.NotifyFieldChanged(() => Mnemonic);
        }
    }

    private ValidationEditContext _validationEditContext;
    private string _mnemonic;

    private async Task Validate()
    {
        if (SelectedOption is null)
        {
            _validationEditContext.MessageStore.Add(() => SelectedOption!, "Please select an option");
            return;
        }

        Mnemonic? mnemonic = null;

        string? xpub = null;
        if (IsMnemonicRequired)
        {
            if (Mnemonic is null)
            {
                _validationEditContext.MessageStore.Add(() => Mnemonic!, "Please provide the matching mnemonic for the wallet");

                return;
            }
            try
            {
                mnemonic = new Mnemonic(Mnemonic);
            }
            catch (Exception e)
            {
                _validationEditContext.MessageStore.Add(() => Mnemonic!, "Invalid mnemonic");
                return;
            }

            var kp = new KeyPath("m/84'/0'/0'");

            xpub = mnemonic.DeriveExtKey().Derive(kp).Neuter().ToString(Network.Main);
        }
        if (SelectedOption == "use-configured-wallet")
        {
            //this is super simplistic. We should be asking for the derivation path, passphrase, have a network configured in the app, etc.
            if (ConfiguredWallet != xpub)
            {
                _validationEditContext.MessageStore.Add(() => Mnemonic!, "The mnemonic provided does not match the configured wallet");
                return;
            }
        }
    }

    [Parameter]
    public EventCallback<ChosenConfiguration> OnConfigurationChosen { get; set; }

    private void OnSubmit()
    {
        var useExisting = SelectedOption == "use-configured-wallet" || SelectedOption == "use-configured-hot-wallet";
        var setStore = SelectedOption != "create-wallet-separate";
        OnConfigurationChosen.InvokeAsync(new ChosenConfiguration(useExisting, setStore, Mnemonic));
    }

    private void GenerateSeed()
    {
        Mnemonic = new Mnemonic(Wordlist.English, WordCount.Twelve).ToString();
    }

    public record ChosenConfiguration(bool UseExisting, bool SetStore, string? Mnemonic);
}
