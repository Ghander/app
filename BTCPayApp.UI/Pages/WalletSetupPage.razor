@page "/wallet/setup"
@inject IDispatcher Dispatcher
@inject BTCPayConnection BTCPayConnection
@inject IState<RootState> State
@using BTCPayApp.UI.Features
@using BTCPayApp.Core
@using BTCPayServer.Client.Models
@using NBitcoin
@inherits Fluxor.Blazor.Web.Components.FluxorComponent

<PageTitle>Wallet Setup</PageTitle>

<MudText Typo="Typo.h5" Class="mb-4">Wallet Setup</MudText>

<BTCPayServerOnchainWalletConfigure
    ConfiguredWallet="@State.Value.PairConfig?.PairingResult?.ExistingWallet"
    IsConfiguredWalletHot="@(State.Value.PairConfig?.PairingResult?.ExistingWalletSeed is not null)"
    OnConfigurationChosen="Callback" />

@code {
    private async Task Callback(BTCPayServerOnchainWalletConfigure.ChosenConfiguration obj)
    {
        var config = State.Value.PairConfig;
        if (config is null) return;

        var kp = new KeyPath("m/84'/0'/0'");
        var seed = new Mnemonic(obj.Mnemonic ?? config.PairingResult.ExistingWalletSeed);
        var mKey = seed.DeriveExtKey();
        var xpub = mKey.Derive(kp).Neuter().ToString(Network.Main);
        if (obj is { UseExisting: false, SetStore: true })
        {
            await BTCPayConnection.Client.UpdateStoreOnChainPaymentMethod(config.PairingResult.StoreId, "BTC", new UpdateOnChainPaymentMethodRequest
            {
                Enabled = true,
                DerivationScheme = xpub,
                AccountKeyPath = new RootedKeyPath(mKey, kp)
            });
        }
        Dispatcher.Dispatch(new RootState.WalletConfigLoadedAction(new WalletConfig
        {
            Mnemonic = seed.ToString(),
            DerivationPath = kp.ToString(),
            StandaloneMode = false
        }));
    }
}
