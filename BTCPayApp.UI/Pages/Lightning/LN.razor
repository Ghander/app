@using BTCPayApp.Core.Attempt2
@using BTCPayServer.Lightning
@using NBitcoin
@using LightningPayment = BTCPayApp.CommonServer.Models.LightningPayment
@using BTCPayApp.Core.Data
@using NBitcoin.Crypto
@inject LightningNodeManager LightningNodeManager
@inject IDispatcher Dispatcher

@if (Loading)
{
    <span>loading...</span>
}
else
{
    <div class="form-floating">
        <TruncateCenter Text="@_nodeId" Padding="15" Copy="true" Elastic="true" class="form-control-plaintext"/>
        <label>Node ID</label>
    </div>
    <article class="my-4">
        <h3>Payments</h3>
        @if (_payments?.Any() is true)
        {
            <div class="table-responsive">
            <table class="table">
                <thead>
                <tr>
                    <th></th>
                    <th>Payment Hash</th>
                    <th>Inbound</th>
                    <th>Id</th>
                    <th>Preimage</th>
                    <th>Secret</th>
                    <th>Timestamp</th>
                    <th>Value</th>
                    <th>Status</th>
                    <th>Invoices</th>
                </tr>
                </thead>
                <tbody>
                @foreach (var payment in _payments)
                {
                    <tr>
                        <td>
                            @if (payment.Status == LightningPaymentStatus.Pending)
                            {
                                <button type="button" class="btn btn-primary btn-sm" @onclick="() => Cancel( payment.Inbound? payment.PaymentHash:payment.PaymentId, payment.Inbound)">Cancel</button>
                            }

                        </td>
                        <td>@payment.PaymentHash</td>
                        <td>@payment.Inbound</td>
                        <td>@payment.PaymentId</td>
                        <td>@payment.Preimage</td>
                        <td>@payment.Secret</td>
                        <td>@payment.Timestamp</td>
                        <td>@payment.Value</td>
                        <td>@payment.Status</td>
                        <td>@string.Join('\n', payment.PaymentRequests)</td>
                    </tr>
                }
                </tbody>
            </table>
            </div>
        }
        else
        {
            <p class="text-muted">There are no payments, yet.</p>
        }

        <div>

            <div class="input-group">
                <input type="number" class="form-control" min="0" @bind="paymentRequestAmt" placeholder="sats"/>
                <button type="button" class=" btn btn-primary" @onclick="ReceivePayment">Receive payment</button>
            </div>


              <div class="input-group">
                            <input type="number" class="form-control" placeholder="explicit amount in sats, optional" min="0" @bind="paymentRequestAmt"/>
                            <input type="text"class="form-control" placeholder="bolt11" @bind="paymentRequestSend"/>
                            <button type="button" class=" btn btn-primary"  @onclick="SendPayment">Send payment</button>
                        </div>


            @if (paymentResponse is not null)
            {
                <p>@paymentResponse</p>
            }
            </div>
    </article>
    <button class="btn btn-outline-primary" type="button" @onclick="FetchData">Refresh data</button>
}

@code {
    private string _nodeId;
    private LightningConfig? _config;
    private List<LightningPayment?>? _payments;
    private LDKNode? Node => LightningNodeManager.Node;
    private decimal? paymentRequestAmt;
    private string? paymentRequestSend;
    private string? paymentResponse;
    private bool Loading { get; set; }
    private SemaphoreSlim _semaphore = new SemaphoreSlim(1, 1);

    protected override void OnInitialized()
    {
        base.OnInitialized();
        _ = FetchData();
    }

    private async Task FetchData()
    {
        Loading = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            await _semaphore.WaitAsync();
            _config = await Node.GetConfig();
            _nodeId = Node.NodeId.ToString();
            _payments = await LightningNodeManager.Node?.PaymentsManager.List(payments => payments);
        }
        finally
        {
            Loading = false;
            await InvokeAsync(StateHasChanged);
            _semaphore.Release();
        }
    }

    private async void ReceivePayment()
    {
        if (Loading || paymentRequestAmt is null) return;
        try
        {
            Loading = true;
            await InvokeAsync(StateHasChanged);
            await _semaphore.WaitAsync();
            var hash = new uint256(Hashes.SHA256(RandomUtils.GetBytes(32)));
            var result = await Node.PaymentsManager.RequestPayment(LightMoney.Satoshis(paymentRequestAmt??0), TimeSpan.FromDays(1), hash);

            paymentResponse = $"Payment request created with invs {string.Join(',',result.PaymentRequests)}";
            paymentRequestAmt = null;
        }
        catch (Exception e)
        {
            paymentResponse = $"Error: {e.Message}";
        }
        finally
        {
            Loading = false;
            await InvokeAsync(StateHasChanged);
            _semaphore.Release();
        }
    }

    private async void SendPayment()
    {
        if (Loading ||  paymentRequestSend is null) return;
        try
        {
            Loading = true;
            await InvokeAsync(StateHasChanged);
            await _semaphore.WaitAsync();
            var invoice = BOLT11PaymentRequest.Parse(paymentRequestSend, Node.Network );
            var result = await Node.PaymentsManager.PayInvoice(invoice, paymentRequestAmt is null? null: LightMoney.Satoshis((long)paymentRequestAmt.Value));
            paymentResponse = $"Payment {result.PaymentId} sent with status {result.Status}";
            paymentRequestAmt = null;
            paymentRequestSend = null;
        }
        catch (Exception e)
        {
            paymentResponse = $"Error: {e.Message}";
        }
        finally
        {
            Loading = false;
            await InvokeAsync(StateHasChanged);
            _semaphore.Release();
        }
    }

    private async void Cancel(string paymentId, bool inb)
    {
        if (Loading) return;
        try
        {
            Loading = true;
            await InvokeAsync(StateHasChanged);
            await _semaphore.WaitAsync();
            await Node.PaymentsManager.Cancel(paymentId, inb);
        }
        finally
        {
            Loading = false;
            await InvokeAsync(StateHasChanged);
            _semaphore.Release();
        }
    }
}
