@page "/wallet/setup"
@inject IDispatcher Dispatcher
@inject BTCPayConnection BTCPayConnection
@inject IState<RootState> State
@using BTCPayApp.UI.Features
@using BTCPayApp.Core
@using BTCPayServer.Client.Models
@using NBitcoin
@inherits Fluxor.Blazor.Web.Components.FluxorComponent
<PageTitle>Wallet setup</PageTitle>
<MudContainer Class="mt-16" MaxWidth="MaxWidth.Medium">
    <BTCPayServerOnchainWalletConfigure ConfiguredWallet="@State.Value.PairConfig?.PairingResult?.ExistingWallet" IsConfiguredWalletHot="@(State.Value.PairConfig?.PairingResult?.ExistingWalletSeed is not null)"  OnConfigurationChosen="Callback"></BTCPayServerOnchainWalletConfigure>
</MudContainer>
@code {
    private async Task Callback(BTCPayServerOnchainWalletConfigure.ChosenConfiguration obj)
    {
        var kp = new KeyPath("m/84'/0'/0'");
        var mKey = new Mnemonic(obj.Mnemonic).DeriveExtKey();
        var xpub = mKey.Derive(kp).Neuter().ToString(Network.Main);
        if (obj is {UseExisting: false,SetStore: true})
        {
            await BTCPayConnection.Client.UpdateStoreOnChainPaymentMethod(State.Value.PairConfig.PairingResult.StoreId, "BTC", new UpdateOnChainPaymentMethodRequest()
            {
                Enabled = true,
                DerivationScheme = xpub,
                AccountKeyPath = new RootedKeyPath(mKey, kp)
            });
        }
        Dispatcher.Dispatch(new RootState.WalletConfigLoadedAction(new WalletConfig()
        {
            Mnemonic = obj.Mnemonic,
            DerivationPath = kp.ToString(),
            StandaloneMode = false
        }));


    }
}