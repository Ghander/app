@inject IState<RootState> State
@using Microsoft.AspNetCore.SignalR.Client
@using BTCPayApp.UI.Features
@using BTCPayApp.Core.Data
@using BTCPayApp.Core.Attempt2
@inherits Fluxor.Blazor.Web.Components.FluxorComponent

<h1 class="mb-3">Dashboard</h1>

@if (State.Value.Loading.Any())
{
    @foreach(var loading in State.Value.Loading)
    {
        <Alert Type="info">@loading.ToString() loading.</Alert>
    }
}

@if (State.Value.OnchainWalletState != OnChainWalletState.NotConfigured)
{
  <Alert Type="success">Wallet: @State.Value.OnchainWalletState</Alert>
}
else if(State.Value.BTCPayServerConnectionState == HubConnectionState.Connected)
{
    <Alert Type="warning">
        <div class="d-flex flex-wrap align-center justify-space-between gap-3">
            Your wallet is not configured.
            <NavLink href="@Routes.WalletSetup" class="btn btn-sm btn-primary">
                Set up a wallet
            </NavLink>
        </div>
    </Alert>
}

@if (State.Value.LightningNodeState != LightningNodeState.NodeNotConfigured)
{
    <Alert Type="info">
        Lightning node loading.
    </Alert>
}
else if(State.Value.OnchainWalletState != OnChainWalletState.NotConfigured && State.Value.BTCPayServerConnectionState == HubConnectionState.Connected)
{
    <div class="alert alert-warning">
        <div class="d-flex flex-wrap align-center justify-space-between gap-3">
            Your Lightning node is not configured.
            <NavLink href="@Routes.WalletSetup" class="btn btn-sm btn-primary">
                Get started
            </NavLink>
        </div>
    </div>
}

@code {
    private string ConnectionStatus => State.Value.BTCPayServerConnectionState?.ToString().ToLowerInvariant() ?? "not connected";

    private string ConnectionSeverity => State.Value.BTCPayServerConnectionState switch {
        HubConnectionState.Disconnected => "warning",
        HubConnectionState.Connected => "success",
        HubConnectionState.Connecting => "info",
        HubConnectionState.Reconnecting => "info",
        _ => "warning"
        };

    private string LightningStatus => State.Value.LightningNodeState switch {
        LightningNodeState.Init => "Init",
        LightningNodeState.NodeNotConfigured => "not configured",
        LightningNodeState.WaitingForConnection => "waiting for connection",
        LightningNodeState.Loading => "loading",
        LightningNodeState.Loaded => "loaded",
        LightningNodeState.Error => "error",
        _ => "unknown"
    };

    private string LightningSeverity => State.Value.LightningNodeState switch {
        LightningNodeState.Loaded => "success",
        LightningNodeState.NodeNotConfigured => "warning",
        LightningNodeState.WaitingForConnection => "warning",
        LightningNodeState.Error => "danger",
        _ => "info"
        };

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return base.OnAfterRenderAsync(firstRender);
        return base.OnAfterRenderAsync(firstRender);
    }

}
